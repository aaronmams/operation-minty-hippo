---
title: "SKills-5-Advanced-Data-Import-v.2"
author: "aaron mamula"
date: "5/4/2020"
output: html_document
---

# {.tabset .tabset-fade .tabset-pills}

This module continues the exploration of 'advanced' data import methods.  The focus here will be on pulling data from an Application Programming Interface (API). More specifically, the module will use the Census Bureau's American Community Survey API to build a data set. 


## A Little (very little) Background

First, a caveat: I should emphasize at the beginning that there are multiple R Packages that will do this work for you. My experience with these packages has not been great but I concede that I'm not usually very patient when it comes to learning the ins-and-outs of wrapper libraries. 

[Here is a reasonably comprehensive list of R Packages built to deal with manipulating Census Bureau Data](https://rconsortium.github.io/censusguide/r-packages-all.html).


### What is an API?

In general [APIs are access points for somebody else's resources](https://www.howtogeek.com/343877/what-is-an-api/) (usually data). For our purposes, it is sufficient to know that an APIs is a url that, depending on how it parameterized, returns some data. 

### What are Census Bureau APIs?

The Census Bureau has a lot of different datasets. On [The Census Bureau's Developers page](https://www.census.gov/data/developers/data-sets.html) one can see the exhaustive list of datasets accessible through APIs. This list includes, but is not limited to:

* The American Community Survey 1-year data
* The American Community Survey 3-year data
* The American Community Survey 5-year data
* The Annual Survey of Entrepreneurs
* The Decennial Census

Each of these data sets may be available for different time intervals, different geographies, and there may be many individual data series inside each of these datasets. Depending on which data set you want to access and what flavor of data you want (2016 v. 2018; state-level versus county-level; etc.) the API text string will look a little different.

## A Quick Overview

The Census ACS APIs are urls that get adorned with some parameters depending on what data series and geography you want. The data gets returned in Java Script Object Notation (JSON) format. Here is the process that I will walk through below:

1. Build the url for a data series using standard base R character string methods
2. Use the *fromJSON()* method from the *RJSONIO* library to fetch the data
3. Data are returned as a list object. I use the *rbindlist()* method from *data.table* and *dplyr* to clean up the list object.

## Data Import Using Census APIs

I'm going to implement steps 1-3 above in a single code chunk to illustrate the simplicity. Then, in the next section, I'll do a step-by-step under the hood thing.

[The Census Bureau's Developers page](https://www.census.gov/data/developers/data-sets/acs-5year.html) shows us the API endpoints for accessing ACS 5-yr averages. In the example below we're going to build a data frame containing total population for each Census Designated Place in California, Oregon, Washington, Alaska, and Hawaii. The total population series will be taken from the 2018 American Communities Survey and we will use the 5-year estimates (these should be the average of the point-in-time values for 2014,2015,2016,2017,& 2018). The following are the crucial pieces of info we will need:

1. an API key. This is a unique key value assigned to individual developers when they register as API users with the Census Bureau.

2. the API endpoint. This is generally a url. For the current case we are going to pull data from the "Detail Tables." The base url for these data are:https://api.census.gov/data/2018/acs/acs5?get=NAME 

Without getting too far into the weeds, I want to make one more point before showing some real life data: In the case of the Census Bureau's ACS data, the base url for the API call gets adorned with some parameters indicating what geography you want data for (state-level, county-level, Census Designated Place, Census Tract) and what specific data series you want.

In the API call below I'm requesting data for all Census Designated Places in the states 06 (CA), 02 (AK), 41 (OR), 53 (WA), and 15 (HI). These parameters are appended to the base url as illustrated below:

```{r include=F, warning=F}
library(RJSONIO)
library(dplyr)
library(data.table)
```

```{r}
#my census API key
key <- "key=f5a32f694a14b28acf7301f4972eaab8551eafda"

# the base url for Detailed Tables for the 2018 ACS 5-year
base <- "https://api.census.gov/data/2018/acs/acs5?get=NAME,"

# geo parameters
geo <-  "&for=place:*&in=state:06,02,41,53,15&"

# data series name
series.name <- 'B01001_001E' #total population

# paste these all together to form the API call for the total population data series
endpoint <- paste(base,series.name,geo,key,sep="")

# get json data
total.pop.list <- fromJSON(endpoint)

# parse json object and coerce to data frame
  pop.df <- tbl_df(data.frame(rbindlist(lapply(total.pop.list,function(x){
    return(data.frame(name=x[1],value=x[2],state=x[3],data_series=series.name))
  })
  ))) %>% filter(row_number() > 1)

```

```{r}
library(DT)
datatable(pop.df, options = list(pageLength = 5))

```

## A Step-by-Step

Just for giggles, I'm going to do the step-by-step with a different data series from the "Detailed Tables". For this I'll use series B01001_003E: Estimated number of males in the population under age 5.

### Step 1: Building the url string

Just as above we need the following pieces of information to build the API call:

* the base url
* the geography parameters
* the data series identifier
* the API key

```{r}
#my census API key
key <- "key=f5a32f694a14b28acf7301f4972eaab8551eafda"

# the base url for Detailed Tables for the 2018 ACS 5-year
base <- "https://api.census.gov/data/2018/acs/acs5?get=NAME,"

# geo parameters
geo <-  "&for=place:*&in=state:06,02,41,53,15&"

# data series name
series.name <- 'B01001_003E' #total population males under 5 years

# paste these all together to form the API call for the total population data series
endpoint <- paste(base,series.name,geo,key,sep="")
endpoint 
```

### Step 2: pass the API call and receive the data

```{r}
# get json data
acs.list <- fromJSON(endpoint)
head(acs.list)
```

Digging a little deeper here, we see that each list item is a character vector containing a value for the Census Designtated Place, the state identifier, the data series value, and a numerical identifier assgined to each CDP. 

```{r}
class(acs.list[[2]])
acs.list[[2]]
```

### Step 3: clean up the data

To clean up these data I am applying a simple function which takes each list item and coerces it to a vector. Since each list item contains a single CDP and the data series value for that CDP, I can create a data frame of these values by stacking the row vectors on top of one another.

Here is the code chunk that takes the list object returned from the *fromJSON()* method and uses it to create a data frame. Note, this code is not run at this stage:

```{r eval=F}
# parse json object and coerce to data frame
  acs.df <- tbl_df(data.frame(rbindlist(lapply(acs.list,function(x){
    return(data.frame(name=x[1],value=x[2],state=x[3],data_series=series.name))
  })
  ))) %>% filter(row_number() > 1)
```

I will now illustrate what's happening by breaking down the individual elements of the code block above.

Let's start with ```function(x){return(data.frame(...))}```. This is just a function that accepts a vector input and coerces it to a data frame. The reason I'm doing this is because the R package *data.table* has a method *rbindlist()* that coerces a list to a data frame...the catch is that each element of the list must be a data frame. So note here:

```{r}
tmp.fn <- function(x){
  return(data.frame(name=x[1],value=x[2],state=x[3],data_series=series.name))
}

test.vector <- c("Someplace, California",100,'06')

# what data type is test.vector
class(test.vector)
```

```{r}
# feed test.vector as an argument to the function above
test.df <- tmp.fn(test.vector)

# what data type is result of tmp.fn
class(test.df)
```

```{r}
# finally, what does the result of tmp.fn look like
test.df
```

Now, let's look at what the *lapply()* method does:

```{r}
tmp <- lapply(acs.list,function(x){
  return(data.frame(name=x[1],value=x[2],state=x[3],data_series=series.name))})
head(tmp)
```

The method *lapply()* applies a function to each element in a list. In this case, the function takes a vector and makes it a dataframe. We can see this by looking at the data types within the original list and the new list (the one that results from applying the function). 

```{r}
class(acs.list[[2]])
class(tmp[[2]])
```

All I'm trying to illustrate with the code block above is this: in the original list each list element was a vector, in the new list each element is a dataframe.

When you have a list of data frames, it's easy to construct a single data frame by using the *rbindlist()* method:

```{r}
class(tmp)
class(data.frame(rbindlist(tmp)))
```

That was pretty long-winded but let me summarize what we did:

1. build the API string to get data series B01001_003E (total male population under age 5) from the ACS 5-year data set for every Census Designated Place in California, Oregon, Washington, Hawaii, and Alaska.

2. passed the API string to the Census and received the data as a list

3. coerced that list to a data frame

## Discussion

Because I've been working with these data for a bit I happen to know that one way (there are others) to get the *total population* data series comes from the "Detailed Tables" and it has the attribute "B01001_001E". [The data dictionary for the "Detailed Tables" is available in html](https://api.census.gov/data/2018/acs/acs5/variables.html), xml, and json formats.  I'm not gonna lie to you, finding the data series identifiers you want if you don't know exactly what you're looking for is pretty rough. Say for instance you wanted the poverty rate by county for counties in California. You could do a cmd+f to search the html table for all data series with "poverty" in the description. But, for the 2018 ACS 5-year data, this would return you 4,755 results...many of which are really finely disaggregated along several dimensions. For instance in the "Detailed Tables" there are:

* there is B05010_001E: RATIO OF INCOME TO POVERTY LEVEL IN THE PAST 12 MONTHS BY NATIVITY OF CHILDREN UNDER 18 YEARS IN FAMILIES AND SUBFAMILIES BY LIVING ARRANGEMENTS AND NATIVITY OF PARENTS
* or B06012_010E: TOTAL NUMBER OF INDIVIDUALS BORN IN A DIFFERENT STATE THAN THEIR STATE OF RESIDENCE BELOW 100% OF THE POVERTY LEVEL

One thing I learned from hours of searchign is that the ACS Profile Tables have some nice summary data that is often what I'm after. On the subject of poverty, the series DP03_0128PE is the percent of households in poverty series. Specifically, [from the Profile html data dictionary](https://api.census.gov/data/2018/acs/acs5/profile/variables.html) I found the entry:

```{r, echo=F}
df <- data.frame(name=c('DP03_0128E'),
           label=c("Estimate!!PERCENTAGE OF FAMILIES AND PEOPLE WHOSE INCOME IN THE PAST 12 MONTHS IS BELOW THE POVERTY LEVEL!!All people"),
           concept=('Selected Economic Characteristics'))
datatable(df)
```


The ACS "Profile Tables" are accessible through a slightly different url than the "Detailed Tables." Referring to the [Census Developer's page for the ACS 5-year data](https://www.census.gov/data/developers/data-sets/acs-5year.html) we can see that the sample API provided for the profile tables is:

https://api.census.gov/data/2018/acs/acs5/profile?get=NAME,group(S0101)&for=us:1

Using this API we can make a few modifications to get the poverty data for California counties:

```{r}

#-----------------------------------------------------
# build the API string

# my API key
key <- "key=f5a32f694a14b28acf7301f4972eaab8551eafda"

# the base url for Detailed Tables for the 2018 ACS 5-year
base <- "https://api.census.gov/data/2018/acs/acs5/profile?get=NAME,"

# geo parameters
geo <-  "&for=place:*&in=state:06&"

# data series name
series.name <- 'DP03_0128PE' #households in poverty

# paste these all together to form the API call for the poverty data series
endpoint <- paste(base,series.name,geo,key,sep="")
#---------------------------------------------------------

# get json data
poverty.data <- fromJSON(endpoint)

# parse json object and coerce to data frame
  poverty.data <- tbl_df(data.frame(rbindlist(lapply(poverty.data,function(x){
    x<-unlist(x)
    return(data.frame(name=x[1],value=x[2],state=x[3],data_series=series.name))
  })
  ))) %>% filter(row_number() > 1)

```


```{r}
datatable(poverty.data, options = list(pageLength = 5))

```

## Building a dataset

The last section covered the basics of using API calls to get Census Bureau data. Now I'm going to string together several API strings to put together a dataset containing social indicators. 

IMHO the real fun with APIs is that you can build data sets programatically. One reason you may want to do somethign like this is to unburden yourself from the demands of maintaining meta-data. Let's look at an example first then I'll say a bit more about self-documenting data.

Here, I'm going to build up a small data set of social indicators. Specifically, I'm going to grab the following:

* DP03_0128PE: percent of people in poverty
* DP02_0064PE: percent of population with a bachelor's degree 
* DP04_0134E: median gross rent for renter occupied housing units
* DP03_0062E: median household income

```{r}
# build the API string
series.data <- data.frame(series.name =c('DP02_0001E','DP03_0128PE','DP02_0064PE','DP04_0134E','DP03_0062E'),
                           series.label=c('Total_Households','Percent_in_poverty','Percent_College','Median_Gross_Rent','Median_Income'))

# my API key
key <- "key=f5a32f694a14b28acf7301f4972eaab8551eafda"
# the base url for Detailed Tables for the 2018 ACS 5-year
base <- "https://api.census.gov/data/2018/acs/acs5/profile?get=NAME,"
# geo parameters
geo <-  "&for=place:*&in=state:06&"

# paste these all together to form the API call for the poverty data series

#create a function to get a clean data frame
data.fn <- function(data.series.name){

  endpoint <- paste(base,data.series.name,geo,key,sep="")
  
  # get json data
  data <- fromJSON(endpoint)

  # parse json object and coerce to data frame
  data <- tbl_df(data.frame(rbindlist(lapply(data,function(x){
    x<-unlist(x)
    return(data.frame(name=x[1],value=x[2],state=x[3],data_series=data.series.name,
                      data_label=series.data$series.label[which(series.data$series.name==data.series.name)]))
  })
  ))) %>% filter(row_number() > 1)
return(data)  
}

indicators <- data.frame(rbindlist(lapply(series.data$series.name,FUN=data.fn)))
```

```{r}
# a final step just to clean up the data
indicators <- indicators %>% mutate(value=as.numeric(as.character(value))) %>%
                     mutate(value=ifelse(value<0,NA,value))
```

### Explore the dataset

Now that I have the data I want to end with something simple but cool: plot each series in relation to the national average.

```{r}
library(tidyr)
library(ggplot2)
library(ggrepel)

# National Averages (got these from quick google searches)

# % below poverty line: 12%
# % w/bachelor's degree: 33.4%
# median income/rent ratio:
#     median gross rent: $1,012
#     median monthly gross income: $3,460


# make a data set with national benchmarks 
us.df <- data.frame(name=rep('U.S',3),value=c(12,33.4,29.2), 
                    data_series=c(1,2,3),data_label=c("Percent_in_poverty","Percent_College","Median_Rent_Income_Ratio"))

# convert to wide format data just to make some plotting easier
indicators.wide <- indicators %>% select(name,value,state,data_label) %>% spread(data_label,value)

# a non-random sample of coastal communities to label
coastal.communities <- indicators.wide %>% filter(name %in% c('Arcata city, California',
                                                              'Eureka city, California',
                                                              'Fields Landing CDP, California',
                                                              'Alderpoint CDP, California',
                                                              'Bayview CDP (Humboldt County), California',
                                                              'Benbow CDP, California',
                                                              'Big Lagoon CDP, California',
                                                              'Cutten CDP, California',
                                                              'Fairhaven CDP, California',
                                                              'Fieldbrook CDP, California',
                                                              'Garberville CDP, California',
                                                              'Hoopa CDP, California',
                                                              'Humboldt Hill CDP, California',
                                                              'Hydesville CDP, California',
                                                              'Indianola CDP, California',
                                                              'Loleta CDP, California',
                                                              'Manila CDP, California',
                                                              'McKinleyville CDP, California',
                                                              'Miranda CDP, California',
                                                              'Myers Flat CDP, California',
                                                              'Myrtletown CDP, California',
                                                              'Orick CDP, California',
                                                              'Phillipsville CDP, California',
                                                              'Pine Hills CDP, California',
                                                              'Redcrest CDP, California',
                                                              'Redway CDP, California',
                                                              'Samoa CDP, California',
                                                              'Scotia CDP, California',
                                                              'Shelter Cove CDP, California',
                                                              'Weott CDP, California',
                                                              'Westhaven-Moonstone CDP, California',
                                                              'Willow Creek CDP, California'))

coastal.communities$name <- gsub(", California","",coastal.communities$name)

#ggplot(coastal.communities, aes(x= log(Total_Households), y= Percent_in_poverty, label=name))+
#  geom_point() +geom_text(aes(label=name),hjust=0, vjust=0,size=3) +
#  geom_hline(yintercept=us.df$value[which(us.df$data_label=='Percent_in_poverty')],color="red") +
#  theme_bw() + ylab("% Poverty") + xlab("Total Households (log)") + 
#  ggtitle("Poverty Rates for CDPs in Humboldt County CA")

ggplot(coastal.communities, aes(x= log(Total_Households), y= Percent_in_poverty, label=name))+
  geom_point(color="blue",size=2.5) + 
  geom_label_repel(aes(label=name),
                   size = 2,
                   box.padding = 0.35,
                   segment.color='grey50') + 
  geom_hline(yintercept=us.df$value[which(us.df$data_label=='Percent_in_poverty')],color="red")+
  theme_classic() +
  ylab("% Poverty") +
  xlab("Total Households (log)") + 
  ggtitle("Poverty Rates for CDPs in Humboldt County, CA")

```


